---
import { mapCategoryName, upperHumanize } from "@lib/textConverter";

interface Props {
  categories: string[];
  className?: string;
}

const { categories, className = "" } = Astro.props;
---

<div class={`category-selector ${className}`}>
  <label for="mobile-category-selector" class="sr-only">เลือกหมวดหมู่</label>
  <select
    id="mobile-category-selector"
    class="w-full glass rounded-lg p-3 border border-black dark:border-gray-600 focus:ring-2 focus:ring-purple-500 focus:border-transparent transition-all font-notoLooped"
    aria-label="เลือกหมวดหมู่"
    data-category-selector
  >
    <option value="">เลือกหมวดหมู่</option>
    {
      categories.map((category) => (
        <option value={category}>{mapCategoryName(category)}</option>
      ))
    }
  </select>
</div>

<script>
  class CategorySelector {
    private selector: HTMLSelectElement | null = null;
    private boundHandleChange: (event: Event) => void;
    private retryCount: number = 0;
    private maxRetries: number = 5;
    
    constructor() {
      this.boundHandleChange = this.handleChange.bind(this);
      this.init();
    }
    
    private init(): void {
      // Wait for DOM to be ready
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => this.setupSelector());
      } else {
        this.setupSelector();
      }
    }
    
    private setupSelector(): void {
      // Try multiple ways to find the selector
      this.selector = document.getElementById('mobile-category-selector') as HTMLSelectElement ||
                     document.querySelector('[data-category-selector]') as HTMLSelectElement ||
                     document.querySelector('.category-selector select') as HTMLSelectElement;
      
      if (this.selector) {
        // Remove any existing listeners first (defensive programming)
        this.selector.removeEventListener('change', this.boundHandleChange);
        this.selector.addEventListener('change', this.boundHandleChange);
        console.log('Category selector initialized successfully');
        this.retryCount = 0; // Reset retry count on success
      } else if (this.retryCount < this.maxRetries) {
        console.warn(`Category selector element not found, retrying... (${this.retryCount + 1}/${this.maxRetries})`);
        this.retryCount++;
        // Retry after a short delay
        setTimeout(() => this.setupSelector(), 100);
      } else {
        console.error('Category selector element not found after maximum retries');
      }
    }
    
    private handleChange(event: Event): void {
      const target = event.target as HTMLSelectElement;
      const selectedCategory = target.value;
      
      if (selectedCategory) {
        const targetUrl = `/blog/categories/${selectedCategory}`;
        
        // Add visual feedback
        target.style.opacity = '0.7';
        target.disabled = true;
        
        try {
          console.log(`Navigating to: ${targetUrl}`);
          
          // Try modern navigation first
          if ('navigation' in window && window.navigation) {
            // Use the new Navigation API if available
            (window.navigation as any).navigate(targetUrl);
          } else {
            // Fallback to window.location.assign for better compatibility
            window.location.assign(targetUrl);
          }
        } catch (error) {
          console.error('Navigation failed, trying fallback:', error);
          // Final fallback to href
          window.location.href = targetUrl;
        } finally {
          // Reset visual state after a delay if navigation failed
          setTimeout(() => {
            target.style.opacity = '1';
            target.disabled = false;
            target.value = ''; // Reset selection
          }, 3000);
        }
      }
    }
    
    public destroy(): void {
      if (this.selector && this.boundHandleChange) {
        this.selector.removeEventListener('change', this.boundHandleChange);
        this.selector = null;
      }
    }
  }
  
  // Initialize when component loads
  let categorySelector: CategorySelector | null = null;
  
  // Initialize with proper timing
  function initCategorySelector() {
    if (!categorySelector) {
      categorySelector = new CategorySelector();
    }
  }
  
  // Initialize immediately if DOM is ready, otherwise wait
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initCategorySelector);
  } else {
    initCategorySelector();
  }
  
  // Cleanup on page unload (for SPA navigation)
  window.addEventListener('beforeunload', () => {
    if (categorySelector) {
      categorySelector.destroy();
      categorySelector = null;
    }
  });
  
  // Also cleanup on Astro page transitions (if using View Transitions)
  document.addEventListener('astro:before-preparation', () => {
    if (categorySelector) {
      categorySelector.destroy();
      categorySelector = null;
    }
  });
</script>

<style>
  .category-selector select {
    background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
    background-position: right 0.5rem center;
    background-repeat: no-repeat;
    background-size: 1.5em 1.5em;
    padding-right: 2.5rem;
  }
  
  .category-selector select:focus {
    outline: none;
  }
  
  /* Dark mode adjustments */
  :global(.dark) .category-selector select {
    background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%9ca3af' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
  }
</style>
